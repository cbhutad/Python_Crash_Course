# Notes

### Function syntax

``` Python 

def functionname(parameters):
    #function body

```

### Docstrings

This are strings which are specified using the 3 quotes as shown below

``` Python

def functionname(parameters):
    """ This is a doc string"""
    #function body

```

This are mainly used for documentation for the function stating what does the function do. It is not mandatory practice but its a good to use them to describe our function. Also during the documentation for a module generated by us the help will display the docstring for the function present if any.

### Parameters and Arguments

- Parameters refers to the variable names defined in the function definition. Whereas the values for the same which are passed in a function call are called as arguments.

- There are mainly 2 ways for passing arguments : 
1) positional arguments
2) keywords arguments

``` Python

def func1(para1, para2):
    #function body

func1(value1,value2)

```

Here we are passing the arguments using the positional arguments way. The arguments are passed to the parameters according to their positions. So para1 will have value1 as value and para2 will have value as value2. So the order for specifying the arguments matters.

``` Python

def func1(para1, para2):
    #function body

func1(para2=value1, para1=value2)

```

Here we are using the keyword arguments approach. So here we specify the key-value pairs as arguments. This way the order of specifying the arguments does not matter. This is preferred approach if we are not using the arbitary number of arguments in the definition.

- Default values as parameters are helpful as we have don't have to use the parameters forcefully. When using the default parameters we can just ignore the same and have the default value used or we can else specify it if required. With the default values in the picture we must make it the last parameter to be defined in the function definition. This way it does not affect the positional arguments applied. However keyword arguments are not affected but still its a good practice to define such a default value at the end of parameter list. This is how we can work with the optional parameters case.

- If we have a parameters with default values then they must be placed after non default parameters else we receive a syntax error `python-verison : 3.11.0`. This is observed even in the case that we call the functions using keyword arguments

``` Python

def describe_pets(animal_type = "dog", pet_name):
    """Display information about pet"""
    print(f"I have a {animal_type}")
    print(f"My {animal_type} name is {pet_name.title()}")

describe_pets(pet_name="Harry")

```
Here we will receive a Syntax error. So the pet_name must be defined before the animal_type.

### None

None is a special type in python which refers to the case when a variable does not holds any specific value.

``` Python

friend = None

```

It results in falsy values in a boolean condition.

### List as a parameter

If a list is passed as argument then the original list if modified inside the function the changes persist. In such a case we can pass the function a copy of list using `listname[:]` as argument. This way we can preserve the original list.

### Arbitary number of arguments

To use this feature the syntax for the variable values paramters is given as `*parametername` and this paramter must be placed at the end of the parameter list. 

``` Python

def make_pizza(size, *toppings):
    #function body

make_pizza("small","cheese","corn","capsicum")

```

Here the arguments cheese, corn and capsicum are all part of variable arguments and will be stored in the toppings parameter. One should note that this arbitary argument parameter is of type tuple. So even if the arguments are repeated they will stored once only.

One more type of such arbitary arguments is to provide a key-value pairs which can be stored in a dictionary. Such type of arbitary arguments parameter must be specified with the syntax `**parametername`. As specified this parameter will be a dictionary object.

``` Python 

def func1(first,second, **skills):
    #function body

func1("value1","value2",firstpara="value3",secondpara="value4")

```

Whenever a variable arguments are being provided the other type of arguments we can use are positional arguments. In such cases keyword arguments are not allowed.

``` Python

def make_pizza(size, *toppings):
    print(f"Making a pizza of size {size} with toppings:")
    for topping in toppings:
        print(f"{topping}")

make_pizza(size="large", "mushrooms", "green peppers", "extra cheese") # this leads to error

```

### Modules

A simple python file containing only the definitions of a functions or variable is called as module. This way we can use this module inside  our other python files so to make use of code reusability.

In order to use a module we must first import it. The syntax for this is `import location-of-file`.

So there are 5 ways to import a  module.
1) `import modulename`

This allows us to import the entire module functions in our file. Here in order to call the functions of module we must use the syntax as `module_name.function_name(arguments)`

2) `from modulename import functioname`

This way we can import only the required functions in our file. Also the function can be called directly without the need to specify the modulename before them. But only the functions imported can be used. Also if we have similar defined function names can be caused ambigiuos function call issue. 

3) `from modulename import *`

This is similar to first case but this will import all the functions in the module for use. Here except from the first case we don't have use the modulename before it.

4) `from modulename import functioname as alias1`

This allows us to define a alias name for the function so as to change it to our liking. This reduces the case of ambigiuos function call issue.

5) `import modulename as alias2`

Here the module itself is given a alias this way we don't have to use the module name and can use aliasname.functionname to call the function.
